\section*{Урок 3}
\begin{itemize} 
	\item функции, перегрузка функции
	\item использование стандартной библиотеки, import
	\item передача данных в функцию (примитивы и объекты)
	\item конструкторы, перегрузка конструктора
	\item ключевое слово this
	\item ключевое слово static
\end{itemize}

	


\subsection*{Функции}
Функция - это набор инструкций, вынесенный в отдельный блок, который можно переиспользовать. Функция должна решать определенную подзадачу. Для каждой функции нужно объявить возвращаемые значение, имя функции и принимаемые значения - аргументы. 
\begin{itemize}
	\item если функция ничего не возвращает, то нужно указать ключевое слово void, иначе нужно указать тип возвращаемого значения
	\item если функция ничего не принимает на вход, то нужно указать пустые скобки, иначе в скобках через запятую описать все аргументы функции <type> <name>
	\item имя функции должно описывать, что она делает. Обычно это английский глагол действия (start(), run(), check()) или описание свойства (isHit(), isAlive())


\end{itemize}

Примеры функций:
\begin{lstlisting}
	// ничего не возвращает, принимает один аргумент String
	void print(String s) {
		System.out.println(s);
	}

	// ничего не принимает, возвращает int
	// имя отражает, что она делает
	int getRandomValue() {
		return new Random().nextInt();
	}
\end{lstlisting}

Каждый класс может иметь любое количество функций (также их называют методы) и полей. Однако нельзя иметь две функции с одним именем и списком аргументов. Использование одного имени и различных аргументов называется перегрузкой функции. Это нужно, чтобы единообразно работать с различными данными. Во время вызова перегруженной функции компилятор сам выбирает более подходящий вариант.

\begin{lstlisting}
	// 1 принимает строку
	void print(String s) {...}
	// 2 принимает числа
	void print(int a, int b) {...}

	// где-то дальше:
	print("Hello"); // будет вызвана 1
	print(1, 4); // будет вызвана 2
\end{lstlisting}

\subsection*{import}
При компиляции программы jvm проверяет, что знает все классы, которые есть в программе. Для этого она ищет определение класса сначала в текущем пакете, а потом в стандартной библиотеке - пакет java.lang*. Этот пакет всегда подключен по умолчанию и делать его импорт не нужно. В этом пакете хранится, например, класс String.
Для того, чтобы указать, где еще нужно искать классы используется ключевое слово import, после которого указывается либо пакет либо конкретный класс. Использование конкретного класса уменьшает размер скомпилированного кода. Классы стандартной библиотеки хранятся в пакетах, имена которых начинаются с java. Если не указать импорт класса, то при компиляции возникнет ошибка - неизвестный символ.

\begin{lstlisting}
	import java.util.Random; // импорт одного класса
	import java.util.*; // импорт всех классов из данного пакетов и его подпакетов
\end{lstlisting}

\subsection*{Передача примитивов в функцию}

Рассмотрим пример:
\begin{lstlisting}
	public static void main(String[] args) {
		int a = 10;
		func(a);
		System.out.println("a=" + a);
	}

	static void func(int x) {
		x = 20;
		System.out.println("x=" + x);
	}

	// Output:
	x=20
	a=10
\end{lstlisting}

Переменная a не изменила своего значения. Это связано с тем, что данные передаются в функцию с помощью копирования. То есть создается копия переменной a внутри функции func() и имеено она изменяется. Аргументы и переменные, которые вы создаете внутри тела функции называются локальными. После завершения функции вся информация об этих переменных исчезнет и память, выделенная под них, освобождается. 

\subsection*{Передача объектов в функцию}
Нам нужно различать понятие объекта и ссылки на объект. Объект создается с помощью ключевого слова new и хранится в памяти. На каждый объект может быть создано много ссылок и через каждую из них можно обращаться к объекту. Так как ссылки по сути относятся к одному объекту в памяти, то изменяя объект через одну ссылку, вы увидите изменения через другую ссылку.

\begin{lstlisting}
	new Ship(); // просто создали объект, ссылок на него нет и работать с ним не получится
	Ship ship = new Ship(); // создали объект и ссылку на него - ship
	Ship sameShip = ship; // теперь у нас 2 ссылки на один объект. Ничего нового не создали

	Ship other = new Ship(); // новый объект
	sameShip = other; // теперь sameShip и other указывают на один объект

	other.length = 3;
	System.out.println(sameShip.length); // равно 3
	sameShip.length = 2;
	System.out.println(other.length); // теперь равно 2

\end{lstlisting}

При передаче объекта в функция ссылка на объект копируется и внутри функции у вас уже новая ссылка на объект. 

\begin{lstlisting}
	Ship ship = new Ship(); // создали объект и ссылку на него - ship
	ship.length = 4;
	func(ship);
	System.out.println(ship.length); // а после выполнения функции length == 1
	
	func(Ship s) {
		s.length = 1;  // копированием создали ссылку s, она указыает на тот же объект, что и ship
	}
\end{lstlisting}

Таким образом, в Java и объекты и примитивы передаются по значению. В случае примитивов копируется значение переменной, в случае объектов копируется значение ссылки.

\subsection*(Классы и конструкторы)
Каждый класс имеет набор полей, которые описывают некоторое состояние. Чтобы задать классу состояние, нужно инициализировать его поля. Так как это очень частая операция, придумали общий для всех классов механизм - конструкторы. Это специальная функция, которая занимается инициализацией полей класса. В конструктор, как и в любую функцию, можно передавать аргументы. Конструктор имеет особый синтаксис объявления:
\begin{itemize}
	\item имя конструктора совпадает с именем класса
	\item не нужно указывать тип возвращаемого значения
	\item не может быть static
	\item как и другие функции, может быть перегружен для разных списков аргументов
	\item каждый класс по умолчанию имеет конструктор по умолчанию (конструктор без аргументов)
\end{itemize}

Если имя аргумента конструктора или функции совпадает с именем поля класса, то для обращения к полю класса используется ссылка this - то есть обращение к текущему классу изнутри. Является хорошей практикой давать аргументам конструктора такие же имена, как у полей класса - это дает большую прозрачность при работе с классом и улучшает читаемость.

Рассмотрим пример конструктора класса Ship
\begin{lstlisting}
	class Ship {
		int x, y;
		int length;
		boolean isVertical;

		Ship() {
			// не принимает аргументов
		}

		// Здесь снаружи указали только длину
		Ship(int length) {
			this.length = length; // Имя аргумента совпадает с именем поля, чтобы их отличать, для 
			// поля используем ссылку this 

			// инициализируем остальные поля самостоятельно
		}

		// А здесь все данные пришли снаружи
		Ship(int x, int y, int length, boolean isVertical) {
			this.x = x;
			this.y = y;
			this.length = length;
			this.isVertical = isVertical;
		}
	}
\end{lstlisting}

\subsection*{static}
Ключевое слово static означает, что переменная либо метод не относятся к отдельному объекту класса, а принадлежат самому классу. Таким образом статическая переменная будет общей для всех объектов класса. Также для доступа к статическим полям и методам не требуется создавать объект, обращаться к ним можно просто через имя класса.
Статические переменные создается при первом обращении к классу.

\begin{lstlisting}
	class Box {
		int a;
		static int id;
	}

	// далее в коде
	int id = Box.id; // объект не создавали, обращаемся через имя класса
	int a = Box.a; // a - это нестатическое поле класса, к нему нельзя обращаться, пока не создали объект

	Box b1 = new Box(); // создали объект и ссылку на него b1
	b1.id = 10; // поменяли значение статической переменной

	Box b2 = new Box(); // создали другой объект, однако он знает, что id == 10
	b2.id = 20; // после этого все экземпляры класса видят, что id == 20


\end{lstlisting}

Статические методы, также как и переменные, не требуют создания объекта (экземпляра класса) для своего вызова. Из статических методов можно вызывать только статические методы.

\begin{lstlisting}
	class Box {
		int a;
		
		public static void main(String[] args) {
			// вызываем статический метод
			print(42);

			// не получится, нужен экземпляр класса
			printBox();


			Box box = new Box();
			box.printBox(); // теперь все работает
		}

		static print(int val) {
			System.out.println("Static: " + val);
		}

		printBox() {
			System.out.println("Box (non-static): " + a);
		}

	}

\end{lstlisting}
















